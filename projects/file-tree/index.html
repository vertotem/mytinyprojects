<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿæ¨¡æ‹Ÿå™¨</title>
    <!-- å¼•å…¥ Tailwind CSS ä»¥å®ç°ç°ä»£åŒ–å’Œå“åº”å¼è®¾è®¡ -->
    <script src="./in/tailwind.css"></script>
    <!-- å¼•å…¥ Font Awesome ä»¥æä¾›æ›´ä¸°å¯Œçš„å›¾æ ‡ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* è‡ªå®šä¹‰æ ·å¼ï¼Œç”¨äºè¡¥å…… Tailwind CSS */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        /* æ–‡ä»¶æ ‘åŸºç¡€æ ·å¼ */
        .file-tree ul {
            padding-left: 1.5rem;
            border-left: 1px solid #e2e8f0;
        }

        .file-tree li {
            list-style: none;
            padding: 0.25rem 0;
        }

        /* éšè—å­çº§ï¼Œé™¤éçˆ¶çº§æœ‰ 'open' ç±» */
        .file-tree .node > ul {
            display: none;
        }

        .file-tree .node.open > ul {
            display: block;
        }
        
        /* æ–‡ä»¶å¤¹å’Œæ–‡ä»¶çš„å…‰æ ‡æ ·å¼ */
        .file-tree .node > div {
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        
        .file-tree .node > div:hover {
            background-color: #f1f5f9;
        }

        .file-tree .file > div {
             cursor: default;
        }
        
        .file-tree .file a {
            text-decoration: none;
            color: inherit;
        }

        /* å±•å¼€/æ”¶èµ·å›¾æ ‡çš„æ—‹è½¬åŠ¨ç”» */
        .file-tree .node > div .toggle-icon {
            transition: transform 0.2s ease-in-out;
            margin-right: 0.5rem;
        }

        .file-tree .node.open > div .toggle-icon {
            transform: rotate(90deg);
        }

        /* æœç´¢é«˜äº®æ ·å¼ */
        .highlight {
            background-color: #fef08a; /* é»„è‰²é«˜äº® */
            color: #713f12;
            padding: 2px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        
        <!-- å¤´éƒ¨åŒºåŸŸ -->
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-gray-900">æ–‡ä»¶ç³»ç»Ÿæ¨¡æ‹Ÿå™¨</h1>
            <p class="text-gray-600 mt-1">é€šè¿‡è§£æ Markdown æ–‡ä»¶åŠ¨æ€ç”Ÿæˆå¯äº¤äº’çš„æ–‡ä»¶æ ‘ã€‚</p>
        </header>

        <!-- æ§åˆ¶ä¸æœç´¢åŒºåŸŸ -->
        <div class="bg-white p-4 rounded-lg shadow-sm mb-6 sticky top-4 z-10">
            <div class="flex flex-col md:flex-row gap-4">
                <!-- æœç´¢æ¡† -->
                <div class="relative flex-grow">
                    <span class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">
                        <i class="fas fa-search"></i>
                    </span>
                    <input type="text" id="searchInput" placeholder="åœ¨æ–‡ä»¶æ ‘ä¸­æœç´¢..." class="w-full pl-10 pr-4 py-2 border rounded-md focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </div>
                <!-- æ§åˆ¶æŒ‰é’® -->
                <div class="flex items-center gap-2">
                    <button id="expandAllBtn" class="w-full md:w-auto bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition flex items-center justify-center gap-2">
                        <i class="fas fa-expand-arrows-alt"></i>
                        <span>å…¨éƒ¨å±•å¼€</span>
                    </button>
                    <button id="collapseAllBtn" class="w-full md:w-auto bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition flex items-center justify-center gap-2">
                        <i class="fas fa-compress-arrows-alt"></i>
                        <span>å…¨éƒ¨æ”¶èµ·</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- æ–‡ä»¶æ ‘å®¹å™¨ -->
        <main id="file-tree-container" class="bg-white p-4 md:p-6 rounded-lg shadow-sm file-tree">
            <!-- æ–‡ä»¶æ ‘å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            <div id="loading" class="text-center text-gray-500">
                <i class="fas fa-spinner fa-spin mr-2"></i>æ­£åœ¨åŠ è½½æ–‡ä»¶æ•°æ®...
            </div>
        </main>

        <!-- é¡µè„š -->
        <footer class="text-center mt-8 text-sm text-gray-400">
            <p>çº¯å‰ç«¯æ–‡ä»¶ç³»ç»Ÿæ¨¡æ‹Ÿå™¨</p>
        </footer>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        const fileTreeContainer = document.getElementById('file-tree-container');
        const searchInput = document.getElementById('searchInput');
        const expandAllBtn = document.getElementById('expandAllBtn');
        const collapseAllBtn = document.getElementById('collapseAllBtn');
        const loadingIndicator = document.getElementById('loading');

        const FOLDER_ICON = 'ğŸ“';
        const FILE_ICON = 'ğŸ“„';

        /**
         * è§£æ Markdown åˆ—è¡¨å¹¶æ„å»ºæ ‘å½¢æ•°æ®ç»“æ„
         * @param {string} markdownText - data.md çš„å†…å®¹
         * @returns {Array} - æ ‘å½¢ç»“æ„æ•°ç»„
         */
        function parseMarkdownToTree(markdownText) {
            const lines = markdownText.split('\n').filter(line => line.trim() !== '');
            const root = { children: [] };
            const stack = [{ node: root, indent: -1 }];
            const mdLinkRegex = /\[(.*?)\]\((.*?)\)/;

            lines.forEach(line => {
                const indent = line.search(/\S/); // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªéç©ºç™½å­—ç¬¦çš„ä½ç½®
                const content = line.trim().replace(/^- /, '');
                
                const match = content.match(mdLinkRegex);
                let newNode;

                if (match) {
                    // å¦‚æœæ˜¯ Markdown é“¾æ¥æ ¼å¼ [text](url)
                    newNode = { name: match[1], url: match[2], children: [] };
                } else {
                    // å¦‚æœæ˜¯æ™®é€šæ–‡æœ¬
                    newNode = { name: content, url: null, children: [] };
                }

                while (stack[stack.length - 1].indent >= indent) {
                    stack.pop();
                }

                stack[stack.length - 1].node.children.push(newNode);
                stack.push({ node: newNode, indent });
            });

            return root.children;
        }

        /**
         * æ ¹æ®æ˜¯å¦ä¸ºæ–‡ä»¶å¤¹è·å–å›¾æ ‡
         * @param {boolean} isFolder - æ˜¯å¦ä¸ºæ–‡ä»¶å¤¹
         * @returns {string} - Emoji å›¾æ ‡
         */
        function getIcon(isFolder) {
            return isFolder ? FOLDER_ICON : FILE_ICON;
        }

        /**
         * é€’å½’æ¸²æŸ“æ–‡ä»¶æ ‘
         * @param {Array} nodes - æ ‘èŠ‚ç‚¹æ•°ç»„
         * @param {number} level - å½“å‰å±‚çº§
         * @returns {HTMLUListElement} - ç”Ÿæˆçš„ ul å…ƒç´ 
         */
        function renderTree(nodes, level = 0) {
            const ul = document.createElement('ul');
            if (level > 0) {
                ul.className = 'ml-4';
            }

            nodes.forEach(node => {
                const li = document.createElement('li');
                const isFolder = node.children && node.children.length > 0;
                
                li.className = isFolder ? 'node' : 'file';

                const div = document.createElement('div');
                div.className = 'flex items-center space-x-2';
                
                const icon = getIcon(isFolder);

                let contentHtml;
                if (isFolder) {
                    contentHtml = `
                        <i class="fas fa-chevron-right toggle-icon text-gray-400 w-3 text-center"></i>
                        <span class="icon">${icon}</span>
                        <span class="name">${node.name}</span>
                    `;
                } else {
                    let fileContent;
                    if (node.url) {
                        let href = node.url;
                        // æ£€æŸ¥æ˜¯å¦ä¸ºæŒ‡å‘ .md æ–‡ä»¶çš„å†…éƒ¨é“¾æ¥
                        if (href.endsWith('.md') && !href.startsWith('http')) {
                            const path = href.replace(/^\.\//, '').replace(/\.md$/, '');
                            href = `doc.html#/${path}`;
                        }
                        // å¯¹äºæ‰€æœ‰å¸¦ url çš„é¡¹ï¼Œéƒ½åˆ›å»ºä¸ºé“¾æ¥
                        fileContent = `<a href="${href}" target="_blank" class="name hover:underline hover:text-blue-600">${node.name}</a>`;
                    } else {
                        // æ²¡æœ‰ url çš„é¡¹ï¼Œä½œä¸ºæ™®é€šæ–‡æœ¬å±•ç¤º
                        fileContent = `<span class="name">${node.name}</span>`;
                    }
                    
                    contentHtml = `
                        <span class="icon ml-5">${icon}</span>
                        ${fileContent}
                    `;
                }
                div.innerHTML = contentHtml;
                li.appendChild(div);

                if (isFolder) {
                    const childrenUl = renderTree(node.children, level + 1);
                    li.appendChild(childrenUl);
                }
                
                ul.appendChild(li);
            });
            return ul;
        }

        /**
         * ä¸»å‡½æ•°ï¼šæ„å»ºæ–‡ä»¶æ ‘
         */
        async function buildFileTree() {
            try {
                const response = await fetch('data.md');
                if (!response.ok) throw new Error('æ— æ³•åŠ è½½ data.md');
                const markdownText = await response.text();
                
                const treeData = parseMarkdownToTree(markdownText);
                const treeElement = renderTree(treeData);
                
                loadingIndicator.style.display = 'none';
                fileTreeContainer.appendChild(treeElement);

            } catch (error) {
                console.error('æ„å»ºæ–‡ä»¶æ ‘å¤±è´¥:', error);
                loadingIndicator.style.display = 'none';
                fileTreeContainer.innerHTML = `<p class="text-red-500">é”™è¯¯ï¼šæ— æ³•åŠ è½½æ•°æ®æ–‡ä»¶ data.mdã€‚è¯·ç¡®ä¿æ–‡ä»¶å­˜åœ¨äºåŒç›®å½•ä¸‹ã€‚</p>`;
            }
        }
        
        // --- äº‹ä»¶ç›‘å¬ ---

        // ç‚¹å‡»å±•å¼€/æ”¶èµ·æ–‡ä»¶å¤¹
        fileTreeContainer.addEventListener('click', (e) => {
            // ç¡®ä¿ç‚¹å‡»çš„ä¸æ˜¯é“¾æ¥æœ¬èº«
            if (e.target.tagName === 'A') {
                return;
            }
            const target = e.target.closest('.node > div');
            if (target) {
                target.parentElement.classList.toggle('open');
            }
        });

        // æœç´¢åŠŸèƒ½
        searchInput.addEventListener('input', () => {
            const searchTerm = searchInput.value.toLowerCase();
            const allItems = fileTreeContainer.querySelectorAll('li');
            
            if (!searchTerm) {
                // æ¸…ç©ºæœç´¢æ—¶é‡ç½®çŠ¶æ€
                allItems.forEach(item => {
                    item.style.display = '';
                    const nameSpan = item.querySelector('.name');
                    if(nameSpan) {
                       nameSpan.innerHTML = nameSpan.textContent; // ç§»é™¤é«˜äº®
                    }
                });
                // æ¢å¤é»˜è®¤æŠ˜å çŠ¶æ€
                collapseAllBtn.click();
                return;
            }

            const matchedItems = new Set();
            
            allItems.forEach(item => {
                const nameSpan = item.querySelector('.name');
                const name = nameSpan ? nameSpan.textContent.toLowerCase() : '';

                if (name.includes(searchTerm)) {
                    matchedItems.add(item);
                    // é«˜äº®åŒ¹é…æ–‡æœ¬
                    const originalText = nameSpan.textContent;
                    const regex = new RegExp(searchTerm, 'gi');
                    nameSpan.innerHTML = originalText.replace(regex, match => `<span class="highlight">${match}</span>`);

                    // å±•å¼€æ‰€æœ‰çˆ¶çº§
                    let parent = item.parentElement;
                    while (parent && parent !== fileTreeContainer) {
                        if (parent.tagName === 'LI' && parent.classList.contains('node')) {
                            parent.classList.add('open');
                            matchedItems.add(parent);
                        }
                        parent = parent.parentElement;
                    }
                } else {
                    // æ¢å¤æœªé«˜äº®çš„æ–‡æœ¬
                    if(nameSpan) nameSpan.innerHTML = nameSpan.textContent;
                }
            });

            // éšè—ä¸åŒ¹é…çš„é¡¹
            allItems.forEach(item => {
                if (matchedItems.has(item)) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
        });

        // å…¨éƒ¨å±•å¼€
        expandAllBtn.addEventListener('click', () => {
            fileTreeContainer.querySelectorAll('.node').forEach(node => node.classList.add('open'));
        });

        // å…¨éƒ¨æ”¶èµ·
        collapseAllBtn.addEventListener('click', () => {
            fileTreeContainer.querySelectorAll('.node').forEach(node => node.classList.remove('open'));
        });

        // åˆå§‹åŒ–
        buildFileTree();
    });
    </script>
</body>
</html>
